#include "property_editor.h"
#include "editor_gui.h"
#include "engine/scene/components.h"
#include "engine/scene/script_registry.h"
#include "extras/IconsFontAwesome6.h"
#include "imgui.h"
#include "nfd.h"
#include "raymath.h"
#include "engine/graphics/asset_manager.h"
#include "engine/graphics/model_asset.h"
#include "engine/scene/project.h"

namespace CHEngine
{

    std::unordered_map<entt::id_type, PropertyEditor::ComponentMetadata> PropertyEditor::s_ComponentRegistry;

    void PropertyEditor::RegisterComponent(entt::id_type typeId, const ComponentMetadata &metadata)
    {
        s_ComponentRegistry[typeId] = metadata;
    }

    static bool DrawTextStyle(TextStyle &style)
    {
        auto pb = EditorGUI::Begin();
        pb.Float("Font Size", style.FontSize).Color("Text Color", style.TextColor);

        const char *alignments[] = {"Left", "Center", "Right"};
        int hAlign = (int)style.HorizontalAlignment;
        if (EditorGUI::Property("H Align", hAlign, alignments, 3)) style.HorizontalAlignment = (TextAlignment)hAlign;

        int vAlign = (int)style.VerticalAlignment;
        if (EditorGUI::Property("V Align", vAlign, alignments, 3)) style.VerticalAlignment = (TextAlignment)vAlign;

        pb.Float("Letter Spacing", style.LetterSpacing).Float("Line Height", style.LineHeight);
        if (pb.Bool("Shadow", style.Shadow) && style.Shadow)
        {
            pb.Float("Shadow Offset", style.ShadowOffset).Color("Shadow Color", style.ShadowColor);
        }
        return pb.Changed;
    }

    static bool DrawUIStyle(UIStyle &style)
    {
        auto pb = EditorGUI::Begin();
        pb.Color("Background", style.BackgroundColor)
          .Color("Hover", style.HoverColor)
          .Color("Pressed", style.PressedColor)
          .Float("Rounding", style.Rounding)
          .Float("Border", style.BorderSize)
          .Color("Border Color", style.BorderColor)
          .Float("Padding", style.Padding);
        return pb.Changed;
    }

    // --- UI Layout Helpers ---




    static bool DrawControlComponentUI(ControlComponent &component)
    {
        bool changed = false;
        auto &rectTransform = component.Transform;

        // --- Anchor Presets ---
        ImGui::Text("Presets:"); ImGui::SameLine();
        if (ImGui::Button("Center")) {
            rectTransform.AnchorMin = {0.5f, 0.5f}; rectTransform.AnchorMax = {0.5f, 0.5f};
            rectTransform.OffsetMin = {-50, -50}; rectTransform.OffsetMax = {50, 50};
            changed = true;
        }
        ImGui::SameLine();
        if (ImGui::Button("Stretch")) {
            rectTransform.AnchorMin = {0.0f, 0.0f}; rectTransform.AnchorMax = {1.0f, 1.0f};
            rectTransform.OffsetMin = {0, 0}; rectTransform.OffsetMax = {0, 0};
            changed = true;
        }

        // Use compact Property instead of Vec2Control to reduce X/Y label clutter
        if (EditorGUI::Property("Pivot", rectTransform.Pivot)) changed = true;
        if (EditorGUI::Property("Anchor Min", rectTransform.AnchorMin, 0.01f, 0.0f, 1.0f)) changed = true;
        if (EditorGUI::Property("Anchor Max", rectTransform.AnchorMax, 0.01f, 0.0f, 1.0f)) changed = true;

        bool isPoint = (rectTransform.AnchorMin.x == rectTransform.AnchorMax.x && rectTransform.AnchorMin.y == rectTransform.AnchorMax.y);
        if (isPoint)
        {
            float width = rectTransform.OffsetMax.x - rectTransform.OffsetMin.x;
            float height = rectTransform.OffsetMax.y - rectTransform.OffsetMin.y;
            float posX = rectTransform.OffsetMin.x + width * rectTransform.Pivot.x;
            float posY = rectTransform.OffsetMin.y + height * rectTransform.Pivot.y;
            
            Vector2 pos = {posX, posY};
            Vector2 size = {width, height};

            if (EditorGUI::Property("Pos", pos)) {
                rectTransform.OffsetMin.x = pos.x - size.x * rectTransform.Pivot.x;
                rectTransform.OffsetMin.y = pos.y - size.y * rectTransform.Pivot.y;
                rectTransform.OffsetMax.x = pos.x + size.x * (1.0f - rectTransform.Pivot.x);
                rectTransform.OffsetMax.y = pos.y + size.y * (1.0f - rectTransform.Pivot.y);
                changed = true;
            }
            if (EditorGUI::Property("Size", size)) {
                rectTransform.OffsetMin.x = pos.x - size.x * rectTransform.Pivot.x;
                rectTransform.OffsetMin.y = pos.y - size.y * rectTransform.Pivot.y;
                rectTransform.OffsetMax.x = pos.x + size.x * (1.0f - rectTransform.Pivot.x);
                rectTransform.OffsetMax.y = pos.y + size.y * (1.0f - rectTransform.Pivot.y);
                changed = true;
            }
        }
        else
        {
            // For stretch, show padding (intuitive positive values)
            float rightPadding = -rectTransform.OffsetMax.x;
            float bottomPadding = -rectTransform.OffsetMax.y;

            if (EditorGUI::Property("Left", rectTransform.OffsetMin.x)) changed = true;
            if (EditorGUI::Property("Top", rectTransform.OffsetMin.y)) changed = true;
            if (EditorGUI::Property("Right", rightPadding)) { rectTransform.OffsetMax.x = -rightPadding; changed = true; }
            if (EditorGUI::Property("Bottom", bottomPadding)) { rectTransform.OffsetMax.y = -bottomPadding; changed = true; }
        }

        if (ImGui::TreeNodeEx("Extra Layout Settings", ImGuiTreeNodeFlags_SpanAvailWidth))
        {
            if (EditorGUI::Property("Rotation", rectTransform.Rotation)) changed = true;
            if (EditorGUI::Property("Scale", rectTransform.Scale)) changed = true;
            if (EditorGUI::Property("Z Order", component.ZOrder)) changed = true;
            if (EditorGUI::Property("Visible", component.IsActive)) changed = true;
            ImGui::TreePop();
        }
        return changed;
    }


    // --- Remaining UI Widgets ---


    static bool DrawInputTextWidget(InputTextControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .String("Text", component.Text)
          .String("Placeholder", component.Placeholder)
          .Int("Max Length", component.MaxLength)
          .Bool("Multiline", component.Multiline)
          .Bool("Read Only", component.ReadOnly)
          .Bool("Password", component.Password);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Box Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.BoxStyle)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawComboBoxWidget(ComboBoxControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Int("Selected Index", component.SelectedIndex);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Items", ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_DefaultOpen))
        {
            for (int i = 0; i < component.Items.size(); i++)
            {
                ImGui::PushID(i);
                char buf[256];
                strncpy(buf, component.Items[i].c_str(), sizeof(buf) - 1);
                if (ImGui::InputText("##item", buf, sizeof(buf)))
                {
                    component.Items[i] = buf;
                    changed = true;
                }
                ImGui::SameLine();
                if (ImGui::Button("X"))
                {
                    component.Items.erase(component.Items.begin() + i);
                    changed = true;
                    ImGui::PopID();
                    break;
                }
                ImGui::PopID();
            }
            if (ImGui::Button("Add Item"))
            {
                component.Items.push_back("New Option");
                changed = true;
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Box Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.BoxStyle)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawProgressBarWidget(ProgressBarControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.Float("Progress", component.Progress, 0.0f, 1.0f)
          .String("Overlay Text", component.OverlayText)
          .Bool("Show Percentage", component.ShowPercentage);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Bar Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.BarStyle)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawImageWidget(ImageControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.File("Texture Path", component.TexturePath, "png,jpg,tga")
          .Color("Tint Color", component.TintColor)
          .Color("Border Color", component.BorderColor);
        if (pb.Changed) changed = true;

        if (!component.TexturePath.empty() && e.HasComponent<ControlComponent>())
        {
            if (ImGui::Button("Set Native Size"))
            {
                auto assetManager = Project::GetActive() ? Project::GetActive()->GetAssetManager() : nullptr;
                if (assetManager)
                {
                    auto textureAsset = assetManager->Get<TextureAsset>(component.TexturePath);
                    if (textureAsset)
                    {
                        auto& texture = textureAsset->GetTexture();
                        auto& rt = e.GetComponent<ControlComponent>().Transform;
                        
                        // Calculate width and height
                        float w = (float)texture.width;
                        float h = (float)texture.height;
                        
                        // Update offsets based on pivot to maintain position
                        rt.OffsetMin.x = -w * rt.Pivot.x;
                        rt.OffsetMax.x =  w * (1.0f - rt.Pivot.x);
                        rt.OffsetMin.y = -h * rt.Pivot.y;
                        rt.OffsetMax.y =  h * (1.0f - rt.Pivot.y);
                        changed = true;
                    }
                }
            }
        }

        if (ImGui::TreeNodeEx("Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawImageButtonWidget(ImageButtonControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .File("Texture Path", component.TexturePath, "png,jpg,tga")
          .Color("Tint Color", component.TintColor)
          .Color("Background Color", component.BackgroundColor)
          .Int("Frame Padding", component.FramePadding);
        if (pb.Changed) changed = true;

        if (!component.TexturePath.empty() && e.HasComponent<ControlComponent>())
        {
            if (ImGui::Button("Set Native Size"))
            {
                auto assetManager = Project::GetActive() ? Project::GetActive()->GetAssetManager() : nullptr;
                if (assetManager)
                {
                    auto textureAsset = assetManager->Get<TextureAsset>(component.TexturePath);
                    if (textureAsset)
                    {
                        auto& texture = textureAsset->GetTexture();
                        auto& rt = e.GetComponent<ControlComponent>().Transform;
                        float w = (float)texture.width;
                        float h = (float)texture.height;
                        rt.OffsetMin.x = -w * rt.Pivot.x;
                        rt.OffsetMax.x =  w * (1.0f - rt.Pivot.x);
                        rt.OffsetMin.y = -h * rt.Pivot.y;
                        rt.OffsetMax.y =  h * (1.0f - rt.Pivot.y);
                        changed = true;
                    }
                }
            }
        }

        if (ImGui::TreeNodeEx("Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawSeparatorWidget(SeparatorControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.Float("Thickness", component.Thickness)
          .Color("Color", component.LineColor);
        if (pb.Changed) changed = true;

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawRadioButtonWidget(RadioButtonControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Int("Selected Index", component.SelectedIndex)
          .Bool("Horizontal", component.Horizontal);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Options", ImGuiTreeNodeFlags_Framed))
        {
            for (int i = 0; i < component.Options.size(); i++)
            {
                ImGui::PushID(i);
                char buf[256];
                strncpy(buf, component.Options[i].c_str(), 255);
                if (ImGui::InputText("##opt", buf, 255)) {
                    component.Options[i] = buf;
                    changed = true;
                }
                ImGui::SameLine();
                if (ImGui::Button("X")) {
                    component.Options.erase(component.Options.begin() + i);
                    changed = true;
                    ImGui::PopID();
                    break;
                }
                ImGui::PopID();
            }
            if (ImGui::Button("Add Option")) {
                component.Options.push_back("New Option");
                changed = true;
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawColorPickerWidget(ColorPickerControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Color("Color", component.SelectedColor)
          .Bool("Show Alpha", component.ShowAlpha)
          .Bool("Show Picker", component.ShowPicker);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawDragFloatWidget(DragFloatControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Float("Value", component.Value)
          .Float("Speed", component.Speed)
          .Float("Min", component.Min)
          .Float("Max", component.Max)
          .String("Format", component.Format);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Box Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.BoxStyle)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawDragIntWidget(DragIntControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Int("Value", component.Value)
          .Float("Speed", component.Speed)
          .Int("Min", component.Min)
          .Int("Max", component.Max)
          .String("Format", component.Format);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Box Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.BoxStyle)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawTreeNodeWidget(TreeNodeControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Bool("Default Open", component.DefaultOpen)
          .Bool("Is Leaf", component.IsLeaf);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawTabBarWidget(TabBarControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Bool("Reorderable", component.Reorderable)
          .Bool("Auto Select New Tabs", component.AutoSelectNewTabs);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawTabItemWidget(TabItemControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Bool("Is Open", component.IsOpen);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawCollapsingHeaderWidget(CollapsingHeaderControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .Bool("Default Open", component.DefaultOpen);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawPlotLinesWidget(PlotLinesControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .String("Overlay Text", component.OverlayText)
          .Float("Scale Min", component.ScaleMin)
          .Float("ScaleMax", component.ScaleMax)
          .Vec2("Graph Size", component.GraphSize);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Values", ImGuiTreeNodeFlags_Framed))
        {
            for (int i = 0; i < component.Values.size(); i++)
            {
                ImGui::PushID(i);
                if (ImGui::DragFloat("##val", &component.Values[i], 0.01f)) changed = true;
                ImGui::SameLine();
                if (ImGui::Button("X")) {
                    component.Values.erase(component.Values.begin() + i);
                    changed = true; ImGui::PopID(); break;
                }
                ImGui::PopID();
            }
            if (ImGui::Button("Add Value")) {
                component.Values.push_back(0.0f);
                changed = true;
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Box Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.BoxStyle)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }

    static bool DrawPlotHistogramWidget(PlotHistogramControl& component, Entity e)
    {
        bool changed = false;
        auto pb = EditorGUI::Begin();
        pb.String("Label", component.Label)
          .String("Overlay Text", component.OverlayText)
          .Float("Scale Min", component.ScaleMin)
          .Float("ScaleMax", component.ScaleMax)
          .Vec2("Graph Size", component.GraphSize);
        if (pb.Changed) changed = true;

        if (ImGui::TreeNodeEx("Values", ImGuiTreeNodeFlags_Framed))
        {
            for (int i = 0; i < component.Values.size(); i++)
            {
                ImGui::PushID(i);
                if (ImGui::DragFloat("##val", &component.Values[i], 0.01f)) changed = true;
                ImGui::SameLine();
                if (ImGui::Button("X")) {
                    component.Values.erase(component.Values.begin() + i);
                    changed = true; ImGui::PopID(); break;
                }
                ImGui::PopID();
            }
            if (ImGui::Button("Add Value")) {
                component.Values.push_back(0.0f);
                changed = true;
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Text Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawTextStyle(component.Style)) changed = true;
            ImGui::TreePop();
        }

        if (ImGui::TreeNodeEx("Box Style", ImGuiTreeNodeFlags_Framed))
        {
            if (DrawUIStyle(component.BoxStyle)) changed = true;
            ImGui::TreePop();
        }

        if (e.HasComponent<ControlComponent>())
        {
            if (ImGui::TreeNodeEx("Layout", ImGuiTreeNodeFlags_Framed))
            {
                if (DrawControlComponentUI(e.GetComponent<ControlComponent>())) changed = true;
                ImGui::TreePop();
            }
        }
        return changed;
    }


    void PropertyEditor::Init()
    {
#define REG_HIDDEN(T, name) \
        Register<T>(name, [](auto&, auto) { return false; }); \
        s_ComponentRegistry[entt::type_hash<T>::value()].Visible = false;

        // --- Core & Rendering (Migrated to InspectorPanel) ---
        REG_HIDDEN(TransformComponent, "Transform");
        s_ComponentRegistry[entt::type_hash<TransformComponent>::value()].AllowAdd = false;

        REG_HIDDEN(ModelComponent, "Model");
        REG_HIDDEN(PointLightComponent, "Point Light");
        REG_HIDDEN(SpotLightComponent, "Spot Light");

        Register<AnimationComponent>("Animation", [](auto& component, auto entity) { return false; }); 

        // --- Physics (Migrated to InspectorPanel) ---
        REG_HIDDEN(ColliderComponent, "Collider");
        REG_HIDDEN(RigidBodyComponent, "RigidBody");

        // --- Gameplay (Migrated to InspectorPanel) ---
        REG_HIDDEN(AudioComponent, "Audio");
        REG_HIDDEN(SpawnComponent, "Spawn Zone");
        REG_HIDDEN(PlayerComponent, "Player");
        REG_HIDDEN(SceneTransitionComponent, "Scene Transition");
        REG_HIDDEN(NativeScriptComponent, "Native Script");

        // --- UI Widgets (Migrated to InspectorPanel) ---
        REG_HIDDEN(ControlComponent, "Rect Transform");
        REG_HIDDEN(ButtonControl, "Button Widget");
        REG_HIDDEN(PanelControl, "Panel Widget");
        REG_HIDDEN(LabelControl, "Label Widget");
        REG_HIDDEN(SliderControl, "Slider Widget");
        REG_HIDDEN(CheckboxControl, "Checkbox Widget");

#undef REG_HIDDEN

        Register<InputTextControl>("Input Text Widget", DrawInputTextWidget);
        Register<ComboBoxControl>("ComboBox Widget", DrawComboBoxWidget);
        Register<ProgressBarControl>("ProgressBar Widget", DrawProgressBarWidget);
        Register<ImageControl>("Image Widget", DrawImageWidget);
        Register<ImageButtonControl>("Image Button Widget", DrawImageButtonWidget);
        Register<SeparatorControl>("Separator Widget", DrawSeparatorWidget);
        Register<RadioButtonControl>("RadioButton Widget", DrawRadioButtonWidget);
        Register<ColorPickerControl>("ColorPicker Widget", DrawColorPickerWidget);
        Register<DragFloatControl>("DragFloat Widget", DrawDragFloatWidget);
        Register<DragIntControl>("DragInt Widget", DrawDragIntWidget);
        Register<TreeNodeControl>("TreeNode Widget", DrawTreeNodeWidget);
        Register<TabBarControl>("TabBar Widget", DrawTabBarWidget);
        Register<TabItemControl>("TabItem Widget", DrawTabItemWidget);
        Register<CollapsingHeaderControl>("CollapsingHeader Widget", DrawCollapsingHeaderWidget);
        Register<PlotLinesControl>("PlotLines Widget", DrawPlotLinesWidget);
        Register<PlotHistogramControl>("PlotHistogram Widget", DrawPlotHistogramWidget);

        // Helper to setup widgets
        auto setupWidget = [](entt::id_type id) {
            auto& metadata = s_ComponentRegistry[id];
            metadata.IsWidget = true;
            metadata.AllowAdd = true;
        };

        setupWidget(entt::type_hash<ButtonControl>::value());
        setupWidget(entt::type_hash<PanelControl>::value());
        setupWidget(entt::type_hash<LabelControl>::value());
        setupWidget(entt::type_hash<SliderControl>::value());
        setupWidget(entt::type_hash<CheckboxControl>::value());
        setupWidget(entt::type_hash<InputTextControl>::value());
        setupWidget(entt::type_hash<ComboBoxControl>::value());
        setupWidget(entt::type_hash<ProgressBarControl>::value());
        setupWidget(entt::type_hash<ImageControl>::value());
        setupWidget(entt::type_hash<ImageButtonControl>::value());
        setupWidget(entt::type_hash<SeparatorControl>::value());
        setupWidget(entt::type_hash<RadioButtonControl>::value());
        setupWidget(entt::type_hash<ColorPickerControl>::value());
        setupWidget(entt::type_hash<DragFloatControl>::value());
        setupWidget(entt::type_hash<DragIntControl>::value());
        setupWidget(entt::type_hash<TreeNodeControl>::value());
        setupWidget(entt::type_hash<TabBarControl>::value());
        setupWidget(entt::type_hash<TabItemControl>::value());
        setupWidget(entt::type_hash<CollapsingHeaderControl>::value());
        setupWidget(entt::type_hash<PlotLinesControl>::value());
        setupWidget(entt::type_hash<PlotHistogramControl>::value());

        // Allow adding Rect Transform directly too
        s_ComponentRegistry[entt::type_hash<ControlComponent>::value()].AllowAdd = true;
    }

    void PropertyEditor::DrawEntityProperties(CHEngine::Entity entity)
    {
        auto &registry = entity.GetScene()->GetRegistry();
        bool isUI = entity.HasComponent<ControlComponent>();
        
        bool hasWidget = false;
        for (auto [id, storage] : registry.storage())
        {
            if (storage.contains(entity) && s_ComponentRegistry.contains(id))
            {
                if (s_ComponentRegistry[id].IsWidget)
                {
                    hasWidget = true;
                    break;
                }
            }
        }

        for (auto [id, storage] : registry.storage())
        {
            if (storage.contains(entity))
            {
                if (s_ComponentRegistry.find(id) != s_ComponentRegistry.end())
                {
                    auto &metadata = s_ComponentRegistry[id];
                    if (!metadata.Visible)
                        continue;

                    // Logic to reduce clutter
                    if (isUI && id == entt::type_hash<TransformComponent>::value())
                        continue;
                    
                    if (hasWidget && id == entt::type_hash<ControlComponent>::value())
                        continue;

                    ImGui::PushID((int)id);
                    metadata.Draw(entity);
                    ImGui::PopID();
                }
            }
        }
    }

    void PropertyEditor::DrawTag(CHEngine::Entity entity)
    {
        if (entity.HasComponent<TagComponent>())
        {
            auto &tag = entity.GetComponent<TagComponent>().Tag;
            char buffer[256];
            memset(buffer, 0, sizeof(buffer));
            strncpy(buffer, tag.c_str(), sizeof(buffer) - 1);

            ImGui::Text("Tag");
            ImGui::SameLine();
            if (ImGui::InputText("##Tag", buffer, sizeof(buffer)))
                tag = std::string(buffer);
        }
    }

    void PropertyEditor::DrawMaterial(CHEngine::Entity entity, int hitMeshIndex)
    {
        if (!entity.HasComponent<ModelComponent>())
            return;

        auto &mc = entity.GetComponent<ModelComponent>();
        if (!mc.Asset)
            return;

        const Model &model = mc.Asset->GetModel();
        
        // Helper to draw a single material instance
        auto DrawMaterialInstance = [](MaterialInstance &mat, int index) {
            std::string header = "Material " + std::to_string(index);
            if (ImGui::CollapsingHeader(header.c_str(), ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::PushID(index);
                
                // Albedo
                ImGui::Text("Albedo");
                EditorGUI::Property("Color", mat.AlbedoColor);
                EditorGUI::Property("Texture", mat.AlbedoPath, "Texture Files (*.png *.jpg *.tga *.bmp)\0*.png;*.jpg;*.tga;*.bmp\0");
                EditorGUI::Property("Use Texture", mat.OverrideAlbedo);
                
                ImGui::Separator();
                
                // PBR
                ImGui::Text("PBR Properties");
                EditorGUI::Property("Metalness", mat.Metalness, 0.01f, 0.0f, 1.0f);
                EditorGUI::Property("Roughness", mat.Roughness, 0.01f, 0.0f, 1.0f);
                EditorGUI::Property("Normal Map", mat.NormalMapPath, "Texture Files (*.png *.jpg *.tga *.bmp)\0*.png;*.jpg;*.tga;*.bmp\0");
                
                // Rendering
                ImGui::Separator();
                ImGui::Text("Rendering");
                EditorGUI::Property("Double Sided", mat.DoubleSided);
                
                ImGui::PopID();
            }
        };

        if (hitMeshIndex >= 0 && hitMeshIndex < model.meshCount)
        {
            // Find specific material for this mesh
            // 1. Check for Mesh Index override
            int slotIndex = -1;
            for (int i = 0; i < mc.Materials.size(); i++)
            {
                if (mc.Materials[i].Target == MaterialSlotTarget::MeshIndex && mc.Materials[i].Index == hitMeshIndex)
                {
                    slotIndex = i;
                    break;
                }
            }
            
            // 2. Check for Material Index override
            if (slotIndex == -1 && model.meshMaterial)
            {
                int matIndex = model.meshMaterial[hitMeshIndex];
                for (int i = 0; i < mc.Materials.size(); i++)
                {
                    if (mc.Materials[i].Target == MaterialSlotTarget::MaterialIndex && mc.Materials[i].Index == matIndex)
                    {
                        slotIndex = i;
                        break;
                    }
                }
            }

            if (slotIndex != -1)
            {
                DrawMaterialInstance(mc.Materials[slotIndex].Material, slotIndex);
            }
            else
            {
                ImGui::Text("No Material Slot assigned to this mesh.");
                if (ImGui::Button("Create Override"))
                {
                    // Create new slot for this mesh
                    MaterialSlot newSlot;
                    newSlot.Name = "Mesh Override " + std::to_string(hitMeshIndex);
                    newSlot.Target = MaterialSlotTarget::MeshIndex;
                    newSlot.Index = hitMeshIndex;
                    mc.Materials.push_back(newSlot);
                }
            }
        }
        else
        {
            // Show all materials
            for (int i = 0; i < mc.Materials.size(); i++)
            {
                DrawMaterialInstance(mc.Materials[i].Material, i);
            }
        }
    }

    void PropertyEditor::DrawAddComponentPopup(CHEngine::Entity entity)
    {
        if (ImGui::BeginPopup("AddComponent"))
        {
            bool isUIEntity = entity.HasComponent<ControlComponent>();

            for (auto &[id, metadata] : s_ComponentRegistry)
            {
                if (!metadata.AllowAdd)
                    continue;

                // Filtering: Only show widgets if the entity is a UI entity
                // (or if it's the ControlComponent itself which can be added to any transform)
                if (metadata.IsWidget && !isUIEntity)
                    continue;

                auto &registry = entity.GetScene()->GetRegistry();
                auto *storage = registry.storage(id);
                if (storage && storage->contains(entity))
                    continue;

                if (ImGui::MenuItem(metadata.Name.c_str()))
                {
                    metadata.Add(entity);
                    ImGui::CloseCurrentPopup();
                }
            }
            ImGui::EndPopup();
        }
    }
} // namespace CHEngine
